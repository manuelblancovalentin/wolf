#!/bin/bash

#####################################################################################
# MAKE SURE WE HAVE ALL SOURCE CODE WE NEED
#####################################################################################
_WOLF_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
_WOLF_DIR=`dirname "$_WOLF_DIR"`
_WOLF_BIN="${_WOLF_DIR}/bin"
if [[ ! -d ${_WOLF_BIN} || ! -f "${_WOLF_BIN}/utils" || ! -f "${_WOLF_BIN}/wolf.run" ]]; then
    printf "\033[1;7;31m [ERROR] - Invalid installation. Some binary files required to run wolf are either missing or unaccessible. Contact your cadadmin to fix this."
fi

#####################################################################################
# Source utils
#####################################################################################
source "${_WOLF_BIN}/utils"

#####################################################################################
# WOLF LIB HANDLER ALIAS
#####################################################################################
_wolf_ip_manager () {

    #####################################################################################
    # Make sure the local folder ".wolf" exists on user's path
    #####################################################################################
    _WOLF_IP_DIR="${HOME}/.wolf/ip"
    if [[ ! -d "$_WOLF_IP_DIR" && ! -L "$_WOLF_IP_DIR" ]]; then 
        _wolf_info "First runtime detected. Creating wolf ip dir at ÷yellow÷\"$_WOLF_IP_DIR\"÷÷"
        mkdir -p "$_WOLF_IP_DIR"
    fi

    #####################################################################################
    # Get list of ips
    #####################################################################################
    _WOLF_IP_LIST=`find "$_WOLF_IP_DIR" -maxdepth 1 -mindepth 1 -type d | sort -n`

    ###########################################
    # Init vars to default values
    #
    ##########################################
    _WOLF_IPMAN_ARGS_COMMAND=
    _WOLF_IPMAN_ARGS_NAME=

    ###########################################
    # Parse flags
    ##########################################
    _WOLF_IPMAN_ARGS_POSITIONAL=()
    while [[ $# -gt 0 ]]; do
        _WOLF_IPMAN_ARGS_KEY="$1"
            case $_WOLF_IPMAN_ARGS_KEY in
                -h|--help)
                    # Help dialog
                    echo -e "Usage $(basename $BASH_SOURCE) [OPTIONS]... [EXTRA_ARGUMENTS]..."
                    echo "Wolf ip manager"
                    echo ""
                    echo "Main arguments taken $(basename $BASH_SOURCE):"
                    echo -e "\t-h, --help\t\tInvokes this dialog.\n"
                    echo -e "Options/commands passed to wolf env:\n"
                    echo -e "\tcreate \t\tCreates a new environment."
                    echo -e "\tlist \t\tList all available environments."
                    echo -e "Arguments taken by \"wolf env create\":\n"
                    echo -e "\t-n, --name \t\tSpecifies the name of the environment."
                    echo -e "Arguments taken by wolf env list:\n"
                    return 0
                    ;;
                list)
                    _WOLF_IPMAN_ARGS_COMMAND="LIST"
                    shift # pass argument
                    ;;
            *)    # unknown option
            _WOLF_IPMAN_ARGS_POSITIONAL+=("$1") # save it in an array for later
            _WOLF_IPMAN_ARGS_POSITIONAL+=("$2")
            shift # past argument
            shift # past value
            ;;
        esac
    done
    set -- "${_WOLF_IPMAN_ARGS_POSITIONAL[@]}" # restore positional parameters

    #############################################
    # Invoke _WOLF_IPMAN_ARGS_COMMAND
    #
    ############################################
    case $_WOLF_IPMAN_ARGS_COMMAND in
        LIST)
            # Print header
            cprintf "$_WOLF_IPMAN_HEADER"
            cprintf "\n÷Blue÷÷bold÷ ÷white÷Available ips                                                                    ÷÷ \n"
            if [[ ! -z $_WOLF_IP_LIST ]]; then
                _WOLF_IP_LIST=($(echo "${_WOLF_IP_LIST[@]}" | xargs))
                _WOLF_IPMAN_ARGS_NUM_IPS="${#_WOLF_IP_LIST[@]}"
                for ((i=0; i<_WOLF_IPMAN_ARGS_NUM_IPS; i++)); do
                    printf " "
                    _wolf_entry "÷÷÷yellow÷`basename ${_WOLF_IP_LIST[$i]}`÷÷       \t${_WOLF_IP_LIST[$i]}"
                done
                unset i
                printf "\n"
            else 
                # Print empty warning message
                cprintf "÷red÷No ips ÷÷detected in ÷yellow÷\"$_WOLF_IP_DIR\"÷÷.\n\n"
            fi
            ;;
        *)
            _wolf_error "Invalid command passed to wolf ipman. Wolf requires at least 1 command to be executed. Valid commands are: ..."
            ;;
    esac

}

###########################################################################################################
# TODO LIST:
#
# 1) Wolf should have 3 main cornerstones: IP/RTL/FLOWS. 
#       a) IPs is basically the libraries and processes. This is managed with ip-man
#
#       b) RTL is project-dependent and it's the set of HDL/RTL/input files used for the design. 
#           although it also includes any custom LEF files, etc.
#
#       c) FLOWS are basically the digital flow scripting for each process and it relates to the 
#           specific options the user might want to set for that specific flow. Obviously if
#           the user picks a technology X and process Y we MUST have some default scripts for the 
#           flow. Nonetheless FLOW here refers to the SPECIFIC FLOW that will be generated after
#           user customization (corners/timing constraints/dont_use cells/etc...). These flows, 
#           despite being made by the user, can be absolutely generic too, and so the user might
#           want to use them for multiple designs. That's should be wolf objective: to allow the
#           user to define a generic (yet customized) flow, and then be able to pick this flow
#           for any desired wolf environment.
#
#   All these should be handled and stored separatedly inside wolf. 
#   Thus, the task of the "ENV" is precisely to setup an environment with a specific combination
#    of a set of {IP-libs/RTL/FLOW}. This way it'd be possible to, say, easily setup two different
#    envs with the same RTL but different processes. That's the dream. One-click button digital
#    flow with two different processes for any design. 
#
#   Hence, the process of creating a wolf ENV is "nothing" but putting together a set of {RTL:x, IP:y, FLOW:z} 
#
#  (wolf environment "α")   (wolf environment "ß")  (wolf environment "µ")  (wolf environment "∂")
#   +-----------------+      +-----------------+     +-----------------+     +-----------------+
#   |      RTL:a      |      |      RTL:a      |     |      RTL:b      |     |      RTL:b      |
#   |      /   \      |      |      /   \      |     |      /   \      |     |      /   \      |
#   |     /     \     |      |     /     \     |     |     /     \     |     |     /     \     |
#   |  IP:m -- FLOW:x |      |  IP:n -- FLOW:x |     |  IP:m -- FLOW:y |     |  IP:m -- FLOW:x |
#   +-----------------+      +-----------------+     +-----------------+     +-----------------+
#   
#   Here, 4 different wolf environments are set. There are 2 RTL sources (a/b), two different technologies/libs (m/n)
#    and two different flows (x/y). 
#       - Environment α and ß apply the same flow to the same RTL, but they use different libraries (this is actually a 
#           weird case because different technologies/ips have different flows, but okay).
#       - Environment α and ∂ apply the same flow and process, but to two different RTLs.
#       - Environment µ and ∂ apply use the same libraries/processes to the same RTL, however they use different flows
#           (say, one focuses more on constraining area and the other one on power, for instance).
#
# 2) IP-MAN: The ipman must be able to keep track of the most important info for each library/ip
#       a) QrcTechfile
#       b) Process
#       c) Foundry
#       d) List of cells of the library.
#       How the process of installing a lib is:
#           ( ) Init lib (give it whatever name you want). Point to a dir. It can even be a custom lib.
#           ( ) Add PDK version
#               ( ) (auto)Install metal stack
#               ( ) (auto)detect qrctechfiles, etc.
#           ( ) Add Digital libraries
#
# 3) WOLF/ENV configuration file:
#       (*) dont_use cells. [DONE - Look at wolf.wizard -> set_dont_use_cells function]
#       ( ) custom DRC/LVS scripts
#       ( ) RTL and top design
#       ( ) process and libs/ips



###############################################
# LEF UTILITIES
#   - GET ALL LAYERS FROM A LEF FILE:
#       grep "LAYER" /asic/Library/TSMC/TSMC65_Merged/Digital/Back_End/lef/tcbn65lp_200a/lef/tcbn65lp_9lmT2.lef | sed 's/^.*LAYER //' | awk '{print $1}'| sort -u
#
#   - GET ALL MACROS FROM A LEF FILE:
#       grep "MACRO" /asic/Library/TSMC/TSMC65_Merged/Digital/Back_End/lef/tcbn65lp_200a/lef/tcbn65lp_9lmT2.lef | sed 's/^.*MACRO //' | awk '{print $1}'| sort -u
#
#   - GET ALL CLASSES FROM A LEF FILE:
#       grep "CLASS" /asic/Library/TSMC/TSMC65_Merged/Digital/Back_End/lef/tcbn65lp_200a/lef/tcbn65lp_9lmT2.lef | sed 's/^.*CLASS //' | awk '{print $1}'| sort -u
#
#   - GET ALL SITES FROM A LEF FILE:
#       grep "SITE" /asic/Library/TSMC/TSMC65_Merged/Digital/Back_End/lef/tcbn65lp_200a/lef/tcbn65lp_9lmT2.lef | sed 's/^.*SITE //' | awk '{print $1}'| sort -u
#
#   - GET ALL TAPCELLS 
#       grep "CLASS ENDCAP" /asic/Library/TSMC/TSMC65_Merged/Digital/Back_End/lef/tcbn65lp_200a/lef/tcbn65lp_9lmT2.lef | sed 's/^.*CLASS //' | awk '{print $1}'| sort -u
#   
##############################################
# SPICE UTILITIES
#   - GET ALL SUBCKTS FROM A SPICE FILE:
#       grep ".subckt" /asic/Library/TSMC/TSMC65_Merged/Digital/Back_End/spice/tcbn65lp_200a/tcbn65lp_200a.spi | sed 's/^.*\.subckt //' | awk '{print $1}'
#
##############################################
# LIB UTILITIES
#   - GET ALL CELLS FROM LIB FILE:
#       grep -E "cell \(\w+\)" /asic/Library/TSMC/TSMC65_Merged/Digital/Front_End/timing_power_noise/ECSM/tcbn65lp_200a/tcbn65lpwcl_ecsm.lib | sed 's/^.*cell (//' | awk '{print $1}' | sed 's/)//' | sort -u
#
##############################################
# VERILOG UTILS
#   - GET ALL MODULES FROM A VERILOG FILE:
#       grep -E "module\s+\w+" /asic/Library/TSMC/TSMC65_Merged/Digital/Front_End/verilog/tcbn65lp_200a/tcbn65lp.v | sed 's/^.*module //' | sed 's/;//' | awk '{print $1}' | sort -u
#
##############################################
# MIXED UTILS
#   - GET ALL MODELS FOR WHICH WE HAVE A VERILOG FILE BUT NOT A TIMING MODEL (OR VICEVERSA)
#       comm -3 <(grep -E "module\s+\w+" /asic/Library/TSMC/TSMC65_Merged/Digital/Front_End/verilog/tcbn65lp_200a/tcbn65lp.v | sed 's/^.*module //' | sed 's/;//' | awk '{print $1}' | sort -u) <(grep -E "cell \(\w+\)" /asic/Library/TSMC/TSMC65_Merged/Digital/Front_End/timing_power_noise/ECSM/tcbn65lp_200a/tcbn65lpwcl_ecsm.lib | sed 's/^.*cell (//' | awk '{print $1}' | sed 's/)//' | sort -u)
#
#
#################################################
# MISC
#   - THIS IS A LIST OF DEVICES OF A PDK
#       cat /asic/Library/TSMC/TSMC65_Merged/PDK/V1.7A_1/1p9m6x1z1u/Techfile/dev.list
#
#   - THIS IS THE MAPFILE
#       cat /asic/Library/TSMC/TSMC65_Merged/PDK/V1.7A_1/1p9m6x1z1u/mapfile
#


